[
  {
    "title": "Next.js Dashboard Tutorial with a Local Database",
    "slug": "nextjs-dashboard-local-db",
    "meta_description": "Set up a Next.js Dashboard tutorial with a local database using Docker. See the repository for details: https://github.com/abel-castro/nextjs-dashboard",
    "content": "I recently followed the Next.js Dashboard tutorial (https://nextjs.org/learn/dashboard-app) and made a few modifications to run the database locally using Docker instead of Vercel's DB hosting. You can check out my repository here: https://github.com/abel-castro/nextjs-dashboard\r\n\r\nI hope this can be useful for someone!\r\n\r\nHappy coding!",
    "date": "2024-06-11",
    "tags": [
      {
        "name": "TypeScript"
      },
      {
        "name": "Next.js"
      }
    ]
  },
  {
    "title": "Learn NestJS with MikroORM by Creating a Blog Project",
    "slug": "learn-nestjs-with-mikroorm-by-creating-a-blog",
    "meta_description": "Discover how to build a blog with NestJS and MikroORM in this step-by-step tutorial. Learn to integrate a PostgreSQL database using Docker and develop a full-featured backend API with this powerful Node.js framework.",
    "content": "In the world of Node.js, frameworks like [NestJS](https://nestjs.com)  have transformed the landscape of building server-side applications by introducing a scalable, maintainable, and modular architecture. Coupled with MikroORM, an intuitive TypeScript ORM, you get a powerful duo that promotes code reliability and database management. This post will guide you through setting up a simple blog application using NestJS and [MikroORM](https://mikro-orm.io).\r\n\r\n## Prerequisites\r\n\r\nBefore we dive in, ensure you have the following installed:\r\n- Node.js\r\n- Docker (for running the PostgreSQL database)\r\n\r\n\r\n## Step 1: Setting Up Your NestJS Project\r\n\r\nFirst, install the NestJS CLI globally, if you haven't already:\r\n\r\n```bash\r\nnpm install -g @nestjs/cli\r\n```\r\n\r\nCreate a new project:\r\n\r\n```bash\r\nnest new blog-nest\r\n```\r\n\r\nNavigate to your project directory:\r\n\r\n```bash\r\ncd blog-nest\r\n```\r\n\r\n## Step 2: Integrating MikroORM\r\n\r\nInstall MikroORM and the PostgreSQL driver:\r\n\r\n```bash\r\nnpm install @mikro-orm/core @mikro-orm/nestjs @mikro-orm/postgresql pg\r\n```\r\n\r\nCreate a `mikro-orm.config.ts` at the root of your project to configure MikroORM:\r\n\r\n```typescript\r\nimport { MikroOrmModuleSyncOptions } from '@mikro-orm/nestjs';\r\nimport { Post } from './src/posts/post.entity';\r\n\r\nconst config: MikroOrmModuleSyncOptions = {\r\n  entities: [Post],\r\n  dbName: 'blog',\r\n  type: 'postgresql',\r\n  user: 'test',\r\n  password: 'test',\r\n};\r\n\r\nexport default config;\r\n```\r\n\r\n## Step 3: Running PostgreSQL in Docker\r\n\r\nSet up a `docker-compose.yml` file to run PostgreSQL:\r\n\r\n```yaml\r\nversion: '3.8'\r\nservices:\r\n  postgres:\r\n    image: postgres:latest\r\n    environment:\r\n      POSTGRES_DB: blog\r\n      POSTGRES_USER: test\r\n      POSTGRES_PASSWORD: test\r\n    ports:\r\n      - \"5432:5432\"\r\n    volumes:\r\n      - postgres-data:/var/lib/postgresql/data\r\nvolumes:\r\n  postgres-data:\r\n```\r\n\r\nStart your PostgreSQL database:\r\n\r\n```bash\r\ndocker-compose up -d\r\n```\r\n\r\n## Step 4: Building the Blog API\r\n\r\nDefine your Post entity:\r\n\r\n```typescript\r\nimport { Entity, PrimaryKey, Property } from '@mikro-orm/core';\r\n\r\n@Entity()\r\nexport class Post {\r\n  @PrimaryKey()\r\n  id!: number;\r\n  @Property()\r\n  title!: string;\r\n  @Property()\r\n  content!: string;\r\n}\r\n```\r\n\r\nCreate the Posts module, service, and controller to handle CRUD operations.\r\n\r\n### Posts Module\r\n\r\n```typescript\r\nimport { Module } from '@nestjs/common';\r\nimport { MikroOrmModule } from '@mikro-orm/nestjs';\r\nimport { PostsController } from './posts.controller';\r\nimport { PostsService } from './posts.service';\r\nimport { Post } from './post.entity';\r\n\r\n@Module({\r\n  imports: [MikroOrmModule.forFeature([Post])],\r\n  controllers: [PostsController],\r\n  providers: [PostsService],\r\n})\r\nexport class PostsModule {}\r\n```\r\n\r\n### Posts Service\r\n\r\n```typescript\r\nimport { Injectable } from '@nestjs/common';\r\nimport { InjectRepository } from '@mikro-orm/nestjs';\r\nimport { EntityRepository } from '@mikro-orm/core';\r\nimport { Post } from './post.entity';\r\n\r\n@Injectable()\r\nexport class PostsService {\r\n  constructor(\r\n    @InjectRepository(Post)\r\n    private readonly postRepository: EntityRepository<Post>\r\n  ) {}\r\n\r\n  async findAll(): Promise<Post[]> {\r\n    return this.postRepository.findAll();\r\n  }\r\n}\r\n```\r\n\r\n### Posts Controller\r\n\r\n```typescript\r\nimport { Controller, Get } from '@nestjs/common';\r\nimport { PostsService } from './posts.service';\r\nimport { Post } from './post.entity';\r\n\r\n@Controller('posts')\r\nexport class PostsController {\r\n  constructor(private readonly postsService: PostsService) {}\r\n\r\n  @Get()\r\n  async findAll(): Promise<Post[]> {\r\n    return this.postsService.findAll();\r\n  }\r\n}\r\n```\r\n\r\n## Step 5: Running the Application\r\n\r\nRun your application and navigate to `http://localhost:3000/api/posts` to see the posts retrieved from the database:\r\n\r\n```bash\r\nnpm run start\r\n```\r\n\r\n## Conclusion\r\n\r\nYou've just set up a basic blog API using NestJS and MikroORM, with a PostgreSQL database running in a Docker container. This project lays the foundation for building scalable and maintainable applications with advanced features like data mapping, dependency injection, and modular architecture.\r\n\r\nFor the complete source code, check out the GitHub repository: [blog-nest](https://github.com/abel-castro/blog-nest).\r\n\r\nNestJS and MikroORM are powerful tools in your Node.js arsenal. By mastering them, you can greatly enhance your backend development capabilities. Happy coding!",
    "date": "2024-06-01",
    "tags": [
      {
        "name": "TypeScript"
      },
      {
        "name": "Rest-API"
      },
      {
        "name": "NestJS"
      },
      {
        "name": "Mikro-ORM"
      },
      {
        "name": "Express"
      },
      {
        "name": "Docker"
      }
    ]
  },
  {
    "title": "The Sports Dashboard now displays the results of the last matchday",
    "slug": "sports-dashboard-displays-last-matchday-results",
    "meta_description": "Discover the latest updates on the Sports Dashboard 2.0 as it now showcases the results of the recent matchday for various European football leagues. Learn how the new task retrieves and processes data, providing convenient insights without navigating through multiple sports news websites.",
    "content": "The Sports Dashboard now displays the results of the last matchday.\r\n\r\n![Sports Dashboard 2.0](https://i.imgur.com/Zchxi4B.png\" Basic analytics\")\r\n\r\nI've been making some updates to the [Sports Dashboard](https://ng.abelcastro.dev/sports-dashboard) to showcase the results of the latest matchday across available leagues. My aim with this project is to provide a convenient overview of major football leagues in Europe without needing to navigate through sports news websites.\r\n\r\nTo achieve this, I've implemented a new task that retrieves results data from [APIFootball](https://apifootball.com), processes it into the required format, and then stores it in the database. The code is designed to be adaptable to different data providers and includes a `DataProviderInterface`, allowing to easy use other data providers if it is needed.\r\n\r\nThis task runs once a day, similar to the task for retrieving standings. The results are now accessible through the endpoint `GET /api/sports/standings/`.\r\n\r\nPlease note that since the dashboard only displays results from the last matchday, there may be instances where the data appears incomplete if not all games have been played yet.\r\n\r\nThe code is publicly available [here](https://github.com/abel-castro/abelcastro.dev/tree/main/app/sports).\r\nEnjoy!",
    "date": "2024-04-14",
    "tags": [
      {
        "name": "Rest-API"
      },
      {
        "name": "Django"
      },
      {
        "name": "Angular"
      }
    ]
  },
  {
    "title": "Avoiding Mocks in Testing Through Single Responsibility and Dependency Injection",
    "slug": "avoiding-mocks-with-srp-and-di-in-testing",
    "meta_description": "This post provides clear examples of how these design principles lead to more reliable, clear, and maintainable tests, contrasting a poorly designed code example with a well-refactored one. Gain insights into creating modular, easier-to-test code that focuses on behavior rather than implementation details.",
    "content": "I personally hate to use mocks or spies when I write tests. Often they make tests more fragile, unclear and unreliable. Personally a way that I learned to avoid them is to adhere to principles like Single Responsibility Principle (SRP) and Dependency Injection (DI). \r\n\r\nOne way to reduce the need for mocks is by designing your code with principles like Single Responsibility Principle (SRP) and Dependency Injection (DI). This makes the code more modular, easier to test, and less reliant on mocks.\r\n\r\nLet me show you what I am talking about with 2 examples:\r\n\r\n\r\n## Bad Example: Hard-coded Dependency\r\nConsider a TypeScript class that directly creates and uses an external library or service within its methods. This tight coupling makes it difficult to test without resorting to mocks.\r\n\r\n```ts\r\nclass EmailService {\r\n    sendEmail(to: string, subject: string, body: string) {\r\n        // Directly using an external email sending library\r\n        const emailClient = new ExternalEmailClient();\r\n        emailClient.configure();\r\n        emailClient.send(to, subject, body);\r\n    }\r\n}\r\n```\r\n\r\n## Testing the Bad Example\r\nTo test the bad example, you'd typically need to use a library that supports mocking global objects or constructors, which can be cumbersome and lead to brittle tests. However, TypeScript itself doesn't directly support mocking like some dynamic languages do, so you'd have to rely on a JavaScript testing framework that allows such operations, like Jest.\r\n\r\nHere's an illustrative example using Jest to mock ExternalEmailClient:\r\nIn this example, EmailService is directly dependent on ExternalEmailClient. To test EmailService's sendEmail method, you would have to mock ExternalEmailClient, which complicates the test setup.\r\n\r\n```ts\r\n// Assume ExternalEmailClient is imported from somewhere\r\njest.mock('./ExternalEmailClient', () => {\r\n  return jest.fn().mockImplementation(() => {\r\n    return {\r\n      configure: jest.fn(),\r\n      send: jest.fn(),\r\n    };\r\n  });\r\n});\r\n\r\ndescribe('EmailService', () => {\r\n  it('should send an email using ExternalEmailClient', () => {\r\n    const emailService = new EmailService();\r\n    emailService.sendEmail('test@example.com', 'Test Subject', 'Test Body');\r\n    // Assertions to verify that ExternalEmailClient was called correctly\r\n    // This part is highly dependent on the mocking framework's API\r\n  });\r\n});\r\n```\r\n\r\nThis approach has several downsides:\r\n\r\n- It relies on global mocks, which can affect other tests if not properly isolated or reset.\r\n- The test is more focused on implementation details (i.e., it tests whether ExternalEmailClient was called) rather than the outcome or behavior of the EmailService.\r\n\r\n\r\n## Good Example: Single Responsibility and Dependency Injection\r\nA better approach is to refactor the code to follow the Single Responsibility Principle and use Dependency Injection. This way, each class has only one reason to change, and dependencies are injected rather than hard-coded.\r\n\r\n```ts\r\ninterface IEmailClient {\r\n    configure(): void;\r\n    send(to: string, subject: string, body: string): void;\r\n}\r\n\r\nclass EmailService {\r\n    private emailClient: IEmailClient;\r\n\r\n    constructor(emailClient: IEmailClient) {\r\n        this.emailClient = emailClient;\r\n    }\r\n\r\n    sendEmail(to: string, subject: string, body: string) {\r\n        this.emailClient.configure();\r\n        this.emailClient.send(to, subject, body);\r\n    }\r\n}\r\n\r\nclass ExternalEmailClient implements IEmailClient {\r\n    configure(): void {\r\n        // Configuration logic for the external email client\r\n    }\r\n\r\n    send(to: string, subject: string, body: string): void {\r\n        // Sending logic for the external email client\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n## Testing the Good Example\r\nTesting the good example is more straightforward and doesn't typically require special mocking libraries. You can easily create a mock or stub that implements the IEmailClient interface and pass it to the EmailService constructor.\r\n\r\nHere's an example using a simple mock object:\r\n\r\n\r\n```ts\r\nclass MockEmailClient implements IEmailClient {\r\n  configureCalled = false;\r\n  sendCalledWith: [string, string, string] | null = null;\r\n\r\n  configure(): void {\r\n    this.configureCalled = true;\r\n  }\r\n\r\n  send(to: string, subject: string, body: string): void {\r\n    this.sendCalledWith = [to, subject, body];\r\n  }\r\n}\r\n\r\ndescribe('EmailService', () => {\r\n  it('should send an email using the provided email client', () => {\r\n    const mockEmailClient = new MockEmailClient();\r\n    const emailService = new EmailService(mockEmailClient);\r\n    emailService.sendEmail('test@example.com', 'Test Subject', 'Test Body');\r\n\r\n    expect(mockEmailClient.configureCalled).toBe(true);\r\n    expect(mockEmailClient.sendCalledWith).toEqual(['test@example.com', 'Test Subject', 'Test Body']);\r\n  });\r\n});\r\n```\r\n\r\nThis testing approach has several advantages:\r\n\r\n- It's clear and straightforward. The mock implementation is easy to understand and control.\r\n- It focuses on the behavior rather than the implementation. You're testing that EmailService uses its IEmailClient dependency correctly, not how IEmailClient is implemented.\r\n- It doesn't require any global mocking or special mocking frameworks, making the tests more reliable and less prone to interference.\r\n\r\n\r\n## Conclusion\r\nThe refactored (good) example not only adheres to the Single Responsibility Principle and employs Dependency Injection for better design but also significantly improves testability. Tests become more focused on behavior rather than implementation, are easier to write and understand, and are less brittle.",
    "date": "2024-02-27",
    "tags": [
      {
        "name": "TypeScript"
      },
      {
        "name": "Testing"
      }
    ]
  },
  {
    "title": "How to Create an Express + TypeORM REST API and Return Data as a Stream",
    "slug": "how-to-create-an-express-typeorm-rest-api-stream",
    "meta_description": "Explore how to build REST APIs using Express and TypeScript ORMs, with a focus on handling data streams efficiently. This post includes practical examples of setting up a PostgreSQL database with TypeORM and demonstrates the advantages of using streams in various scenarios like file processing and real-time data feeds.",
    "content": "Recently, I have been learning [how to develop REST APIs using Express and how to write tests for them](https://github.com/abel-castro/blog-express). As part of my learning journey, I have also been exploring TypeScript ORMs capable of handling [streams](https://developer.mozilla.org/en-US/docs/Web/API/Streams_API). \r\n\r\nA stream is a sequence of data elements made available over time, used for handling large volumes of data or continuous data flow. Streams are useful because they allow for efficient processing of data chunks as soon as they are available, without waiting for the entire data set. This is particularly helpful in managing resources and improving performance in applications like real-time data feeds, file processing, and network communications.\r\n\r\nStreams can be particularly useful in various scenarios, such as:\r\n\r\n- File Processing: When handling large files, streams can read and process data in chunks, preventing memory overload and enabling efficient data handling.\r\n- Network Communications: Streams are ideal for handling data over network requests and responses, such as in web APIs, where data can be processed as it arrives rather than waiting for the complete set.\r\n- Real-time Data Feeds: For applications like social media feeds, stock tickers, or live sports updates, streams allow for real-time processing and display of incoming data.\r\n- Audio/Video Streaming: Media streaming services use streams to deliver content in a buffered manner, enabling smooth playback while the rest of the data is being received.\r\n- Data Transformation: In ETL (Extract, Transform, Load) operations, streams can efficiently process and transform data before it's loaded into a database or another system.\r\n- Log Processing: For applications that generate large volumes of logs, streams can help in efficiently reading and processing log data for monitoring or analytics.\r\n- Chat Applications: Streams enable the implementation of real-time messaging features in chat applications, handling continuous data flow between users.\r\n\r\nFor this purpose, I created the [blog-orm repository](https://github.com/abel-castro/blog-orm/), which showcases how to interact with a PostgreSQL database using [TypeORM](https://typeorm.io) and return data as a stream.\r\n\r\nFor creating the DB `Post` table you just need to implement a `Post.ts` entity and `data-source.ts`:\r\n\r\n```typescript\r\n//entity/Post.ts\r\nimport { Entity, PrimaryGeneratedColumn, Column } from \"typeorm\"\r\n\r\n@Entity()\r\nexport class Post {\r\n    @PrimaryGeneratedColumn()\r\n    id: number\r\n\r\n    @Column()\r\n    title: string\r\n\r\n    @Column()\r\n    content: string\r\n\r\n    @Column()\r\n    isPublished: boolean\r\n}\r\n```\r\n\r\n```typescript\r\n//data-source.ts\r\nimport \"reflect-metadata\"\r\nimport { DataSource } from \"typeorm\"\r\nimport { Post } from \"./entity/Post\"\r\n\r\nexport const AppDataSource = new DataSource({\r\n    type: \"postgres\",\r\n    host: \"localhost\",\r\n    port: 5432,\r\n    username: \"postgres\",\r\n    password: \"postgres\",\r\n    database: \"blog\",\r\n    synchronize: true,\r\n    logging: false,\r\n    entities: [Post],\r\n    migrations: [],\r\n    subscribers: [],\r\n})\r\n```\r\n\r\nA service could look like that:\r\n\r\n```typescript\r\n//postService.ts\r\nimport { AppDataSource } from \"./data-source\";\r\nimport { Post } from \"./entity/Post\";\r\n\r\nexport async function getAllStream() {\r\n    return await AppDataSource.getRepository(Post).createQueryBuilder(\"post\").stream();\r\n}\r\n```\r\n\r\nAnd finally the controller:\r\n\r\n```typescript\r\n//controller.ts\r\nimport { Request, Response, NextFunction } from \"express\";\r\nimport * as postService from \"./postService\"\r\nimport { pipeline } from \"stream/promises\";\r\nimport Disassembler from 'stream-json/Disassembler';\r\nimport Stringer from 'stream-json/Stringer';\r\n\r\nexport async function getAllStream(req: Request, res: Response, next: NextFunction) {\r\n    try {\r\n        const stream = await postService.getAllStream();\r\n        res.setHeader('Content-Type', 'application/json');\r\n        const tokenizer = new Disassembler();\r\n        const jsonStream = new Stringer({ makeArray: true });\r\n        pipeline(stream, tokenizer, jsonStream, res)\r\n    } catch (error) {\r\n        console.error(error);\r\n        res.status(500).send('An error occurred');\r\n    }\r\n}\r\n```\r\n\r\n\r\nAnd that's the whole magic! You can find the complete code in [this repository](https://github.com/abel-castro/blog-orm).",
    "date": "2023-11-20",
    "tags": [
      {
        "name": "TypeScript"
      },
      {
        "name": "TypeORM"
      },
      {
        "name": "Stream"
      },
      {
        "name": "Rest-API"
      },
      {
        "name": "Express"
      }
    ]
  },
  {
    "title": "Sports Dashboard",
    "slug": "sports-dashboard-project",
    "meta_description": "Sports Dashboard, a project designed to sharpen my Angular skills while providing football enthusiasts with a straightforward way to check the latest standings in Europe's top leagues.",
    "content": "I am big football (soccer) fan and follow sports news daily. However, even with this routine, I often find myself unfamiliar with the current standings in the Premier League, Serie A, or other leagues.\r\n\r\nIn my view, football coverage these days is overwhelmingly occupied with topics like transfer rumors, relegating actual match outcomes to secondary importance.\r\n\r\nThis observation sparked the idea for my latest project: [Sports Dashboard](https://ng.abelcastro.dev/sports-dashboard). This Angular-based website displays the standings of the most prominent football leagues across Europe. Additionally, the Austrian Bundesliga features on the site not because it's one of Europe's most critical competitions, but because I reside in Austria and wish to stay informed about local football.\r\n\r\n### The API\r\nTo provide the frontend with data I developed a new REST endpoint: `GET https://abelcastro.dev/api/sports/standings/`.\r\n\r\nThe data will be automatically updated every day at 2 AM.\r\n\r\n\r\n### Upting the data\r\nI have implemented a [management command import_league_standings.py](https://github.com/abel-castro/abelcastro.dev/blob/main/app/sports/management/commands/import_league_standings.py), which is scheduled to run daily via a cron job on the server.\r\n\r\n\r\n### Conclusion \r\n My goal with this project was to become familiar with Angular, and for me, the best way to achieve that is by working on a real project. In this case, the project turned out to be something truly useful. I hope the [Sports Dashboard](https://ng.abelcastro.dev/sports-dashboard) will also help me to reduce the frequency of my visits to sports news pages.",
    "date": "2023-11-07",
    "tags": [
      {
        "name": "Rest-API"
      },
      {
        "name": "Django"
      },
      {
        "name": "Angular"
      }
    ]
  },
  {
    "title": "Learning Angular by using it on my blog",
    "slug": "learning-angular-adding-to-my-blog",
    "meta_description": "Join me on my Angular learning journey as I integrate it into my existing Django-powered blog. Discover the seamless blend of these technologies and the exciting possibilities it offers. Learn and experiment with Angular while still keeping the core of my blog intact. 🛠️💡",
    "content": "I wanted to share a little adventure I had while learning Angular. My blog at abelcastro.dev was doing just fine with Django, but I thought, \"Why not tinker around with Angular and learn some new skills?\" So, I created a playground at [ng.abelcastro.dev](https://ng.abelcastro.dev) and decided to see what I could do!\r\n\r\n### Exploring Angular Fun\r\n\r\nAngular is a fantastic toolbox for making web applications more interactive. Even though my blog was working perfectly with Django, I wanted to learn Angular just for the sake of learning, not necessarily to make it look fancier.\r\n\r\n### Setting Up Angular Playground ([ng.abelcastro.dev](https://ng.abelcastro.dev))\r\n\r\nFirst things first, I set up a separate space for Angular at [ng.abelcastro.dev](https://ng.abelcastro.dev). This way, I could experiment and learn without interfering with the good old Django backend.\r\n\r\n### Smooth Data Flow with a RESTful API\r\n\r\nTo make things flow smoothly, I created a pathway for my Angular app to access the blog's data using a RESTful API at `abelcastro.dev/api/posts´ in my Django backend. This API helps Angular fetch blog posts.\r\n\r\n### The Django Side of Things\r\n\r\nIn the Django world, I used the Django REST framework to create the `/api/posts` endpoint. This way, my Angular app can easily fetch the blog post data it needs.\r\n\r\n### Angular App: Fetching the Data\r\n\r\nInside the Angular app, I used Angular's HttpClient module to fetch data from the Django backend's `/api/posts`.\r\n\r\n### Conclusion\r\nYou can find the repository for my new angular blog [here](https://github.com/abel-castro/ng.abelcastro.dev) 🚀.",
    "date": "2023-10-05",
    "tags": [
      {
        "name": "TypeScript"
      },
      {
        "name": "Rest-API"
      },
      {
        "name": "ChatGPT"
      },
      {
        "name": "Angular"
      }
    ]
  },
  {
    "title": "Mocking APIs with json-server: A Step-by-Step Guide",
    "slug": "mocking-apis-with-json-server-a-step-by-step-guide",
    "meta_description": "Learn how to easily mock APIs using json-server. Follow this step-by-step guide to create a mock API for seamless development and testing.",
    "content": "## Introduction\r\n\r\nDuring the development of web applications, working with APIs is a common task. However, sometimes APIs might not be fully developed or available, which can hinder the development process. To overcome this challenge, developers often resort to mocking APIs to simulate their behavior. One popular tool for achieving this is `json-server`. In this article, we'll walk you through the process of mocking an API using `json-server` and provide an example of how to create a mock API with custom data.\r\n\r\n## Getting Started\r\n\r\n1. **Installation**: First, ensure you have Node.js installed on your machine. If not, download and install it from the official Node.js website. Once Node.js is installed, open your terminal and install `json-server` globally using npm:\r\n\r\n```\r\nnpm install -g json-server\r\n```\r\n\r\n2. **Create a JSON File**: Start by creating a JSON file to hold your mock data. You can use any text editor or IDE to create this file. For example, let's create a file named `db.json` with the following content:\r\n\r\n```json\r\n{\r\n \"products\": [\r\n   {\r\n     \"id\": 1,\r\n     \"name\": \"Mock Product 1\",\r\n     \"price\": 19.99\r\n   },\r\n   {\r\n     \"id\": 2,\r\n     \"name\": \"Mock Product 2\",\r\n     \"price\": 29.99\r\n   }\r\n ]\r\n}\r\n```\r\n\r\n   Save this file in your project directory.\r\n\r\n3. **Start the Mock Server**: Open your terminal, navigate to the directory containing `db.json`, and start the mock server by running:\r\n\r\n```\r\njson-server --watch db.json\r\n```\r\n\r\n   The mock server will start at `http://localhost:3000`.\r\n\r\n4. **Accessing the Mock API**: You can now access your mock API by sending HTTP requests to the appropriate endpoints. In our case, the data will be available at `http://localhost:3000/products`.\r\n\r\n## Customizing the Mock API\r\n\r\nThe example above showcased a simple mock API for products. You can customize the data and structure of the API according to your application's needs. Add more endpoints, nested data, or different types of data to match your requirements.\r\n\r\n## Conclusion\r\n\r\n`json-server` is a valuable tool for developers to create mock APIs that simulate real API behavior. It allows you to continue developing frontend components without waiting for backend APIs to be fully implemented. By following the steps outlined in this article, you can quickly set up a mock API for testing and development purposes. This approach enhances productivity and ensures a smooth development process, even when working with incomplete or unavailable APIs. Happy mocking!",
    "date": "2023-08-23",
    "tags": [
      {
        "name": "Rest-API"
      },
      {
        "name": "ChatGPT"
      }
    ]
  },
  {
    "title": "The Django n+1 issue and solutions for it",
    "slug": "django-n-plus-1-issue-and-solutions-for-it",
    "meta_description": "Discover the n+1 issue in Django and learn how to solve it for improved performance. Get tips and solutions for using select_related and prefetch_related.",
    "content": "Django is a popular and powerful web framework for Python that has become the go-to choice for many web developers. However, one common performance problem that can occur when using Django is the \"n+1\" issue. This problem can arise when querying a large amount of data, leading to increased loading times and decreased performance. In this blog post, we'll explore what the n+1 issue is, why it occurs, and how to solve it.\r\n\r\n## What is the n+1 issue in Django?\r\n\r\nThe n+1 issue occurs when querying a large amount of data from a database. Consider the following example: you have a model that represents a blog post, and you want to retrieve a list of all blog posts along with the author of each post. To do this, you might run the following code:\r\n\r\n```python\r\nposts = BlogPost.objects.all()\r\nfor post in posts:\r\n    author = post.author\r\n```\r\n\r\nWhile this code will retrieve all the information you need, it can be slow and inefficient when dealing with large amounts of data. The reason for this is that it will execute a separate SQL query for each post to retrieve the author information. This can lead to an excessive number of SQL queries and slow down your application.\r\n\r\n## Why does the n+1 issue occur in Django?\r\n\r\nThe n+1 issue occurs because Django does not retrieve all the data for a relationship in a single query. Instead, it retrieves data for each relationship as it is needed. In the example above, this means that Django will execute a separate SQL query for each post to retrieve the author information. This can lead to a large number of SQL queries and slow down your application.\r\n\r\n## How to solve the n+1 issue in Django?\r\n\r\nThere are several ways to solve the n+1 issue in Django, and the best solution depends on your specific use case. Here are some common solutions:\r\n\r\n1) Use the `select_related` method\r\n\r\nThe `select_related` method is a convenient way to retrieve related data in a single query. You can use it to retrieve the author information for all posts in a single query like this:\r\n\r\n```python\r\nposts = BlogPost.objects.all().select_related('author')\r\n\r\nfor post in posts:\r\nauthor = post.author\r\n```\r\n\r\n\r\n2) Use the `prefetch_related ` method\r\n\r\nThe `prefetch_related ` method is similar to `select_related`, but it is more flexible and can be used for more complex relationships. You can use it to retrieve the author information for all posts in a single query like this:\r\n\r\n```python\r\nposts = BlogPost.objects.all().prefetch_related('author')\r\n\r\nfor post in posts:\r\nauthor = post.author\r\n```\r\n\r\n## Conclusion\r\n\r\nThe n+1 issue is a common performance problem that can occur when using Django. By understanding what the n+1 issue is, why it occurs, and how to solve it, you can ensure that your Django applications run smoothly and efficiently.\r\n\r\n\r\n\r\n## Did you liked this article? \r\n\r\nThis content was generated by ChatGPT at 9th February 2023 with the following questions:\r\n- Write a blog post about django n+1 issues and solutions for it\r\n- Generate a markdown file with that content\r\n- Write a meta description for this post \r\n\r\nThe original post had a solution number 3 that looked like this:\r\n\r\nUse the in operator: The in operator can be used to retrieve multiple records in a single query. You can use it to retrieve the author information for all posts in a single query like this:\r\n\r\n```python\r\nposts = BlogPost.objects.all()\r\nauthor_ids = [post.author_id for post in posts]\r\nauthors = Author.objects.filter(id__in=author_ids)\r\n```\r\n\r\nI told ChatGPT that this is not a solution for the issue and it answered this:\r\n\r\n\r\n\r\n> \"Thank you for pointing that out. You're correct, using the in operator as I described in Solution 3 is not a direct solution for the n+1 issue. It is more of a workaround that can be used to reduce the number of SQL queries, but it doesn't address the root cause of the problem.\"",
    "date": "2023-02-09",
    "tags": [
      {
        "name": "Django"
      },
      {
        "name": "ChatGPT"
      }
    ]
  },
  {
    "title": "Django ORM - call queryset update() in json field when the key to update is not present",
    "slug": "call-queryset-update-in-json-field-key-not-present",
    "meta_description": "This post describes using the Django ORM how to call update in json field when the key to update is not present.",
    "content": "I learnt today that this is not possible with the Django ORM to call update in a queryset json field when the key that you want to update is not present. For example:\r\n\r\n```python\r\nqueryset.update(json_data__key=\"something\")\r\n```\r\n\r\nThis will return `FieldDoesNotExist: ModelClass has no field named 'json_data__key'`  because some objects does not have the key “key”.\r\n\r\nI found in [this stackoverflow post](https://stackoverflow.com/a/45308014) a great solution for this. \r\n\r\n```python\r\nfrom django.db.models.expressions import Func\r\n\r\nclass JsonSetValue(Func):\r\n    function = \"jsonb_set\"\r\n    template = \"%(function)s(%(expressions)s, '{\\\"%(keyname)s\\\"}','\\\"%(new_value)s\\\"', %(create_missing)s)\"\r\n    arity = 1\r\n\r\n    def __init__(\r\n        self,\r\n        expression: str,\r\n        keyname: str,\r\n        new_value: str,\r\n        create_missing: bool = False,\r\n        **extra,\r\n    ):\r\n        super().__init__(\r\n            expression,\r\n            keyname=keyname,\r\n            new_value=new_value,\r\n            create_missing=\"true\" if create_missing else \"false\",\r\n            **extra,\r\n        )\r\n```\r\n\r\nWith help of `JsonSetValue` you will be able to do the following:\r\n\r\n```python\r\nqueryset.update(\r\n    json_data=JsonSetValue(\r\n        \"json_data\",\r\n        keyname=\"key\",\r\n        new_value=\"something\",\r\n        create_missing=True,\r\n    )\r\n)\r\n```",
    "date": "2022-05-31",
    "tags": [
      {
        "name": "Postgres"
      },
      {
        "name": "Django"
      }
    ]
  },
  {
    "title": "Sync model fields using Postgres triggers",
    "slug": "sync-model-fields-using-postgres-triggers",
    "meta_description": "How to create Postgres triggers for syncing model fields between two different models.",
    "content": "**The goal:** \r\n\r\nSync some model fields between two different models.\r\n\r\nExample scenario:\r\n\r\n```\r\nclass PlayerData(models.Model):\r\n\tgoals = models.IntegerField()\r\n\tassists = models.IntegerField()\r\n\ttackles = models.IntegerField()\r\n\t# 10 fields more with player data \r\n\r\n\r\nclass PlayerMostRelevantData(models.Model):\r\n\tplayer_data_id = models.ForeignKey(PlayerData, on_delete=models.CASCADE)\r\n\tgoals = models.IntegerField()\r\n\tassists = models.IntegerField()\r\n```\r\n\r\nWe want to keep the data of `PlayerData` and `PlayerMostRelevantData` on sync by every create, update and object deletion. \r\n\r\n**Possible solutions:**\r\n\r\nOf course for this task we could use [django signals](https://docs.djangoproject.com/en/4.0/topics/signals/) but a more reliable solution would be to make the data synchronisation at database level using [Postgres triggers](https://www.postgresql.org/docs/9.1/sql-createtrigger.html).\r\n\r\nFollowing SQL-Snippet explain what we want to achieve. If you run the statements you will see that inserting a new row in the table called \"original\" will create a new row with the same content in the table \"original_copy\".\r\n\r\n```\r\ndrop table if exists original;\r\ncreate table original(id int, name text);\r\ndrop table if exists original_copy;\r\ncreate table original_copy(original_id int PRIMARY KEY, name text);\r\n\r\n\r\ncreate or replace function trigger_on_example()\r\nreturns trigger language plpgsql as $$\r\nbegin\r\n    insert into original_copy (original_id, name)\r\n    values(new.id, new.name)\r\n    ON CONFLICT (original_id)\r\n    DO\r\n        UPDATE SET name = new.name;\r\n\treturn new;\r\nend\r\n$$;\r\n\r\ncreate trigger trigger_on_example\r\nbefore insert or update on original\r\nfor each row execute procedure trigger_on_example();\r\n\r\ninsert into original (id, name)\r\nvalues (1, 'John');\r\n\r\nselect *\r\nfrom original;\r\n\r\nselect *\r\nfrom original_copy;\r\n```\r\n\r\n\r\n**The solution**\r\n\r\nFor our example with the `PlayerData` and `PlayerMostRelevantData` we can write a django migration like this that creates the Postgres triggers for us in the database.\r\n\r\n```python\r\n\r\nfrom django.db import connection, migrations\r\n\r\n\r\ndef create_triggers(apps, schema_editor):\r\n    with connection.cursor() as cursor:\r\n        # player data create or update trigger\r\n        cursor.execute(\r\n            \"\"\"\r\n            create or replace function trigger_on_player_data_create_or_update()\r\n            returns trigger language plpgsql as $$\r\n            begin\r\n               insert into players_playerdata(player_data_id, goals, assists, tackles)\r\n               values(new.id, new.goals, new.assists, new.tackles)\r\n               ON CONFLICT (player_data_id)\r\n               DO\r\n                   UPDATE SET player_data_id = new.id, goals = new.goals,\r\n                   assists = new.assists;\r\n               return new;\r\n            end\r\n            $$;\r\n            create trigger trigger_on_player_data_create_or_update\r\n            before insert or update on players_playerdata\r\n            for each row execute procedure trigger_on_player_data_create_or_update();\r\n            \"\"\"\r\n        )\r\n\r\n        # player data delete trigger\r\n        cursor.execute(\r\n            \"\"\"\r\n            create or replace function trigger_on_player_data_delete()\r\n            returns trigger language plpgsql as $$\r\n            begin\r\n               delete from players_playermostrelevantdata where player_data_id=old.id;\r\n               return NULL;\r\n            end\r\n            $$;\r\n            create trigger trigger_on_player_data_delete\r\n            before delete on players_playerdata\r\n            for each row execute procedure trigger_on_player_data_delete();\r\n            \"\"\"\r\n        )\r\n\r\n\r\nclass Migration(migrations.Migration):\r\n\r\n    dependencies = [\r\n        (\"players\", \"0001_initial\"),\r\n    ]\r\n\r\n    operations = [migrations.RunPython(create_triggers, reverse_code=migrations.RunPython.noop)]\r\n\r\n\r\n```\r\n\r\n\r\n\r\nSources and inspiration:\r\n\r\n- https://www.postgresqltutorial.com/postgresql-upsert/\r\n- https://stackoverflow.com/a/40901037\r\n- https://objectpartners.com/2019/01/24/creating-raw-sql-migrations-in-django/",
    "date": "2022-03-22",
    "tags": [
      {
        "name": "Postgres"
      },
      {
        "name": "Django"
      }
    ]
  },
  {
    "title": "My self made and hosted google analytics alternative",
    "slug": "my-self-made-hosted-google-analytics-alternative",
    "meta_description": "In this post I describe my self made and hosted Google Analytics alternative that uses Django and Chart.js.",
    "content": "![Basic analytics](https://i.imgur.com/3NqGi9A.png \"Basic analytics\")\r\n\r\nI didn't wanted to use Google Analytics or similar tools to track the traffic of my side projects because: a) I don't need that much details about my views and b) I don't want to have a cookie consent dialog for asking for permission to forward user related data to a 3rd party service.\r\n\r\nBecause of that I use a self made and hosted service for tracking basic web traffic analytics stuff: [basic_analytics](https://github.com/abel-castro/basic_analytics).\r\n\r\nIt is made with [Django](https://www.djangoproject.com), [Bootstrap](https://getbootstrap.com) and [chart.js](https://www.chartjs.org) and provides an API endpoint where you can send the page view data as payload.\r\n\r\nWith that data it can generate different charts that show:\r\n- Monthly average page views\r\n- Page views by urls\r\n- Browser, country, device and operative system distribution of the views\r\n- Filter all this data by real user views or include robots views\r\n\r\n**Update February 2022**\r\n\r\nIn order to send data to Basic Analytics from the backend I created a Django app called [django_basic_analytics_tracker](https://github.com/abel-castro/django_basic_analytics_tracker).\r\nIt provides a mixin that you can use in the views that you want to track. It overrides the `dispatch` method, take some request data and sends it to basic analytics service in the post payload.",
    "date": "2021-12-20",
    "tags": [
      {
        "name": "Django"
      },
      {
        "name": "Chart.js"
      }
    ]
  },
  {
    "title": "My initial macOS setup - tools and resources list",
    "slug": "my-initial-macos-setup-tools-and-resources",
    "meta_description": "This is a collection of commands and resources that were useful for me with the initial setup of my MacBook.",
    "content": "This is a collection of commands and resources that were useful for me with the initial setup of my MacBook. \r\n\r\n\r\n- Installs Xcode Command Line Tools \r\n```\r\nxcode-select --install\r\n```\r\n- [Generate SSH key and add it to the ssh agent](https://docs.github.com/en/authentication/connecting-to-github-with-ssh/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)\r\n- Homebrew [https://brew.sh/](https://brew.sh/)\r\n- Oh my zsh [https://ohmyz.sh/](https://ohmyz.sh/)\r\n- nvm [https://github.com/nvm-sh/nvm#git-install](https://github.com/nvm-sh/nvm#git-install)\r\n- Install Docker Desktop [https://docs.docker.com/desktop/mac/install/](https://docs.docker.com/desktop/mac/install/)\r\n- Rectangle: Move and resize windows in macOS using keyboard shortcuts or snap areas [https://rectangleapp.com/](https://rectangleapp.com/)\r\n- Add some shell aliases. I can't work without these:\r\n```\r\nalias g='git'\r\nalias gc='git checkout'\r\nalias gco='git commit'\r\nalias gs='git status'\r\nalias gp='git pull'\r\n\r\nalias dc='docker-compose'\r\nalias up='docker-compose up'\r\nalias down='docker-compose down'\r\n```",
    "date": "2021-10-07",
    "tags": [
      {
        "name": "macOS"
      },
      {
        "name": "Docker"
      },
      {
        "name": "Django"
      }
    ]
  },
  {
    "title": "Django and htmx",
    "slug": "django-and-htmx",
    "meta_description": "I created a repository with some implementations with Django of the code examples from the htmx docs page.",
    "content": "With [htmx](https://htmx.org) is possible to build dynamic Webapps without REST-APIs and JavaScript. Just simple Django views that returns html.\r\n\r\nYou can learn more about it in this interesting [Django chat podcast episode](https://djangochat.com/episodes/htmx-carson-gross) with the htmx creator Carson Gross.\r\n\r\nI really like the idea and I wanted since a while to try htmx working together with Django and finally, I managed to work on that. I created [this repository](https://github.com/abel-castro/django-htmx-demo) with some implementations with Django of the code [examples from the htmx docs page](https://htmx.org/examples/).\r\n\r\n**Update: **also this website has some htmx magic on it. For example the post pagination or the search function are built with htmx.",
    "date": "2021-08-27",
    "tags": [
      {
        "name": "Htmx"
      },
      {
        "name": "Django"
      }
    ]
  },
  {
    "title": "Using variables in the Dockerfile FROM statement",
    "slug": "using-variables-in-the-Dockerfile-from-statement",
    "meta_description": "This article demonstrates how to use a variable as image in the Dockerfile FROM statement",
    "content": "This demonstrates how to use a variable as image for the Dockerfile FROM statement. \r\n \r\nGiven this docker-compose.yml / Dockerfile setup:\r\n\r\n**docker-compose.yml**\r\n\r\n```yml\r\nversion: '3'\r\nservices:\r\n\tpostgres:\r\n\t    build:\r\n\t      context: .\r\n\t      dockerfile: ./compose/postgres/Dockerfile\r\n\t    volumes:\r\n\t\t\t\t- postgres_data:/var/lib/postgresql/data\r\n\t    env_file:\r\n\t      - .env\r\nvolumes:\r\n    postgres_data:\r\n```\r\n\r\n\r\n**Dockerfile**\r\n\r\n```yml\r\nFROM postgres:12.3\r\n```\r\n\r\nThe Postgres service will always use the same FROM image defined in the Dockerfile.\r\nIf we want instead to set the FROM image using a variable, we can do the following:\r\n\r\n\r\n**Docker-compose.yml**\r\n- pass a build_image arg with a default value\r\n\r\n```yml\r\nversion: '3'\r\nservices:\r\n\tpostgres:\r\n\t    build:\r\n\t      context: .\r\n\t      dockerfile: ./compose/postgres/Dockerfile\r\n\t      args:\r\n\t       build_image: \"${BUILD_IMAGE:-postgres:12.3}\" \r\n\t    volumes:\r\n\t\t\t\t- postgres_data:/var/lib/postgresql/data\r\n\t    env_file:\r\n\t      - .env\r\nvolumes:\r\n    postgres_data:\r\n```\r\n\r\n\r\n**Dockerfile**\r\n- use the passed build_image arg in the FROM statement\r\n\r\n```yml\r\n# this will be the default image\r\nARG build_image=\"postgres:12.3\"\r\n\r\n# The default image will be overriden if other build image is passed as ARG\r\nARG build_image=$build_image\r\nFROM $build_image\r\n```\r\n\r\n**.env**\r\n-  Pass the desired value in .env\r\n\r\n```\r\nBUILD_IMAGE=postgis:9.6\r\n```",
    "date": "2021-06-01",
    "tags": [
      {
        "name": "Docker"
      }
    ]
  },
  {
    "title": "Create and use \"dummy\" Models in a Test Case in Django",
    "slug": "create-dummy-models-in-a-test-case-in-django",
    "meta_description": "Example of how to create a \"dummy\" Model and use it in a test case in Django.",
    "content": "Let's image we need a new model only for a test case and we don't really want to register in our project.  We can create something similar than this:\r\n\r\n**example_app.tests.test_app.models.TestModel**\r\n\r\n```python\r\nfrom django.db import models\r\n\r\n\r\nclass TestModel(models.Model):\r\n    field_a = models.IntegerField()\r\n    field_b = models.IntegerField()\r\n\r\n    class Meta:\r\n        app_label = 'test_app'\r\n```\r\n\r\nWe could try to use `TestModel` and create objects in a test case:\r\n**test_models.py**\r\n\r\n```python\r\nfrom django.test import TestCase\r\n\r\nfrom example_app.tests.test_app.models import TestModel\r\n\r\n\r\nclass TestOverridingInstalledApps(TestCase):\r\n    def setUp(self):\r\n        self.test_model = TestModel.objects.create(\r\n            field_a=1,\r\n            field_b=2,\r\n        )\r\n\r\n    def test_objects(self):\r\n        self.assertEqual(TestModel.objects.count(), 1)\r\n```\r\n\r\nBut if you run the tests like this, the test will fail and return something similar than that:\r\n\r\n**./manage.py test**\r\n\r\n```\r\ndjango.db.utils.ProgrammingError: relation \"test_app_testmodel\" does not exist\r\nLINE 1: INSERT INTO \"test_app_testmodel\" (\"field_a\", \"field_b\") VALU...\r\n```\r\n\r\nIt fails because Django needs to have `TestModel` registered in INSTALLED_APPS but we don't really want to add our `example_app.tests.test_app` to INSTALLED_APPS because we only need it when we run the tests. \r\n\r\nThe solution is to to add the test_app to the settings with [modify_settings](https://docs.djangoproject.com/en/dev/topics/testing/tools/#django.test.SimpleTestCase.modify_settings) and calling migrate.\r\n\r\n**test_models.py**\r\n\r\n```python\r\nfrom django.core.management import call_command\r\nfrom django.test import TestCase, modify_settings\r\n\r\nfrom example_app.tests.test_app.models import TestModel\r\n\r\n\r\n@modify_settings(INSTALLED_APPS={\r\n    'append': 'example_app.tests.test_app',\r\n})\r\nclass TestOverridingInstalledApps(TestCase):\r\n    def setUp(self):\r\n        call_command('migrate', run_syncdb=True)\r\n        self.test_model = TestModel.objects.create(\r\n            field_a=1,\r\n            field_b=2,\r\n        )\r\n\r\n    def test_objects(self):\r\n        self.assertEqual(TestModel.objects.count(), 1)\r\n```\r\n\r\n\r\nYou can see the complete source code [here](https://github.com/abel-castro/creating_models_in_tests_example).",
    "date": "2021-04-17",
    "tags": [
      {
        "name": "Testing"
      },
      {
        "name": "Django"
      }
    ]
  },
  {
    "title": "Test inheritance with python (and Django)",
    "slug": "test-inheritance-with-python",
    "meta_description": "Example of test inheritance with python, Django and pytest.",
    "content": "Let's image that we have this models: \r\n\r\n\r\n**models.py**\r\n\r\n```python\r\nclass Athlete(models.Model):\r\n    name = models.CharField(max_length=255)\r\n    slug = models.SlugField(max_length=300, unique=True)\r\n    age = models.PositiveIntegerField()\r\n\r\n    class Meta:\r\n        abstract = True\r\n\r\n\r\nclass BasketballPlayer(Athlete):\r\n    points_scored = models.PositiveIntegerField()\r\n    assists = models.PositiveIntegerField()\r\n    rebounds = models.PositiveIntegerField()\r\n\r\n    def __str__(self):\r\n        return self.name\r\n\r\n\r\nclass SoccerPlayer(Athlete):\r\n    goals_scored = models.PositiveIntegerField()\r\n    assists = models.PositiveIntegerField()\r\n    yellow_cards = models.PositiveIntegerField()\r\n\r\n    def __str__(self):\r\n        return self.name\r\n\r\n```\r\n\r\nWe also provide these 2 GET endpoints:\r\n\r\n  - api/athletes/basketball-player/[slug]\r\n  - api/athletes/soccer-player/[slug]\r\n\r\n\r\nAnd we want to test that every endpoint returns a 200 code and also be sure that serialized data looks like we expect.\r\n\r\n\r\n**tests.py**\r\n\r\n```python\r\nclass TestBasketballPlayerAPI(TestCase):\r\n    def setUp(self) -> None:\r\n        self.basketball_player = create_test_basketball_player()\r\n\r\n    def test__response_ok(self):\r\n        url = reverse_lazy(\r\n            \"basketball_player\", kwargs={\"slug\": self.basketball_player.slug}\r\n        )\r\n        response = self.client.get(url)\r\n\r\n        assert response.status_code == 200\r\n        assert response.data == BasketballPlayerSerializer(self.basketball_player).data\r\n\r\n\r\nclass TestSoccerPlayerAPI(TestCase):\r\n    def setUp(self) -> None:\r\n        self.soccer_player = create_test_soccer_player()\r\n\r\n    def test__response_ok(self):\r\n        url = reverse_lazy(\"soccer_player\", kwargs={\"slug\": self.soccer_player.slug})\r\n        response = self.client.get(url)\r\n\r\n        assert response.status_code == 200\r\n        assert response.data == SoccerPlayerSerializer(self.soccer_player).data\r\n```\r\n\r\nBoth test classes `TestBasketballPlayerAPI` and `TestSoccerPlayerAPI` are very similar. Both check that a 200 is returned and the serialized data. \r\n\r\nLet's try to refactor this. We could make a base class `AthleteTest` for the tests and inherit from it.\r\n\r\n\r\n```python\r\nclass AthleteTest(TestCase):\r\n    view_name = \"\"\r\n    serializer_class = None\r\n\r\n    def setUp(self) -> None:\r\n        self.test_athlete = None\r\n\r\n    @mark.django_db\r\n    def test__response_ok(self):\r\n        url = reverse_lazy(\r\n            self.view_name, kwargs={\"slug\": self.test_athlete.slug}\r\n        )\r\n        response = self.client.get(url)\r\n\r\n        assert response.status_code == 200\r\n        assert response.data == self.serializer_class(self.test_athlete).data\r\n\r\n\r\nclass TestBasketballPlayerAPI(AthleteTest):\r\n    view_name = \"basketball_player\"\r\n    serializer_class = BasketballPlayerSerializer\r\n\r\n    def setUp(self) -> None:\r\n        self.test_athlete = create_test_basketball_player()\r\n\r\n\r\nclass TestSoccerPlayerAPI(AthleteTest):\r\n    view_name = \"soccer_player\"\r\n    serializer_class = SoccerPlayerSerializer\r\n\r\n    def setUp(self) -> None:\r\n        self.test_athlete = create_test_soccer_player()\r\n\r\n```\r\n\r\nThe code is now much shorter and easier to extend with new test cases. But if we try to run pytest it will fail.\r\nPytest will collect 3 test cases and fail because `AthleteTest` is not actually a test case and it is only intended to be inherit from it.\r\n\r\nIn order to avoid this problem we can use the option `__test__`. After adding it the test will look like this:\r\n\r\n```python\r\nclass AthleteTest(TestCase):\r\n    __test__ = False\r\n    view_name = \"\"\r\n    serializer_class = None\r\n\r\n    def setUp(self) -> None:\r\n        self.test_athlete = None\r\n\r\n    @mark.django_db\r\n    def test__response_ok(self):\r\n        url = reverse_lazy(\r\n            self.view_name, kwargs={\"slug\": self.test_athlete.slug}\r\n        )\r\n        response = self.client.get(url)\r\n        assert response.status_code == 200\r\n        assert response.data == self.serializer_class(self.test_athlete).data\r\n\r\n\r\nclass TestBasketballPlayerAPI(AthleteTest):\r\n    __test__ = True\r\n    view_name = \"basketball_player\"\r\n    serializer_class = BasketballPlayerSerializer\r\n\r\n    def setUp(self) -> None:\r\n        self.test_athlete = create_test_basketball_player()\r\n\r\n\r\nclass TestSoccerPlayerAPI(AthleteTest):\r\n    __test__ = True\r\n    view_name = \"soccer_player\"\r\n    serializer_class = SoccerPlayerSerializer\r\n\r\n    def setUp(self) -> None:\r\n        self.test_athlete = create_test_soccer_player()\r\n```\r\n\r\nNow pytest will only collect 2 test and pass as expected.\r\n\r\n\r\nCheckout the complete source code [here](https://github.com/abel-castro/test-inheritance-example).\r\n\r\nNote: this method only works with pytest and NOT with the Django test runner.",
    "date": "2021-03-26",
    "tags": [
      {
        "name": "Testing"
      },
      {
        "name": "Pytest"
      },
      {
        "name": "Django"
      }
    ]
  },
  {
    "title": "My first post",
    "slug": "my-first-post",
    "meta_description": "This blog is built with Django because I thought that if I'm going to write about Django and Python it makes sense that this blog is made with them.",
    "content": "Hi Internet! Welcome to my blog. I will write about topics mostly related to Python and in special to Django.\r\n\r\nThis blog is also built with Django because I thought that if I'm going to write about Django and Python it makes sense that this blog is made with them.\r\n\r\nYou can find the source code in [my GitHub](https://github.com/abel-castro/abelcastro.dev).\r\n\r\nIt is a simple Django project with a Markdown editor for writing posts in the Django admin. For my me and this blog is exactly what I need but if you are looking for a CMS you should take a look to [Wagtail](http://wagtail.io).\r\n\r\n\r\nFeatures of my blog project:\r\n- Django + Postgres + Nginx\r\n- Markdown support powered by [Martor](https://github.com/agusmakmun/django-markdown-editor)\r\n- Dockerized development and production setups\r\n- HTTPS for production\r\n\r\nNote that the production environment is going to serve the media and static files with Nginx. I took the decision to have this \"all-in-one setup\" because I am not expecting to have a lot of traffic here. Please consider to use a cloud storage service if you are expecting more visitors in your website.",
    "date": "2021-03-25",
    "tags": []
  }
]
